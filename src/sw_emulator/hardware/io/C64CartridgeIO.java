/**
 * @(#)C64CartridgeIO.java 2000/01/19
 *
 * ICE Team Free Software Group
 *
 * This file is part of C64 Java Software Emulator.
 * See README for copyright notice.
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
 *  02111-1307  USA.
 */

package sw_emulator.hardware.io;

import sw_emulator.hardware.signaller;
import sw_emulator.hardware.cpu.M6510;
import sw_emulator.hardware.chip.PLA82S100;
import sw_emulator.util.AndPort;

/**
 * The cartridge io in the C64.
 * The signals generated by the cartridge are passed to the internal chip of the
 * C64.
 * The signals that are passed to internal C64 chips are:
 * <ul>
 *  <li>GAME  </li>
 *  <li>EXROM </li>
 *  <li>NMI   </li>
 *  <li>IRQ   </li>
 *  <li>DMA   </li>
 * </ul>
 *
 * Note that the DMA signal is send to two AND port: one for generating the CAEC
 * cpu signal (with AEC from VIC), the second for generating RDY cpu signal
 * (with BA from VIC).
 *
 * @author Ice
 * @version 1.00 19/01/2000
 */
public class C64CartridgeIO extends CartridgeIO {

  /**
   * The 6510 cpu in the C64
   */
  protected M6510 cpu;

  /**
   * The PLA chip in the C64
   */
  protected PLA82S100 pla;

  /**
   * The and port 6 of 74LS08 in the C64
   */
  protected AndPort and6;

  /**
   * The and port 3 of 74LS08 in the C64
   */
  protected AndPort and3;

  /**
   * Construct the connection in the C64 needed by the Cartridge io signals.
   *
   * @param cpu the 6510 cpu
   * @param pla the PLA C64 chip
   * @param and6 the and port 6 of 74LS08 in the C64
   * @param and3 the and port 3 of 74LS08 in the C64
   */
  public C64CartridgeIO(M6510 cpu, PLA82S100 pla, AndPort and6, AndPort and3) {
    this.cpu=cpu;
    this.pla=pla;
    this.and6=and6;
    this.and3=and3;
  }

  /**
   * Notify a signal to the chip
   * The signals that are passed to internal C64 chips are:
   * <ul>
   *  <li>GAME  </li>
   *  <li>EXROM </li>
   *  <li>NMI   </li>
   *  <li>IRQ   </li>
   *  <li>DMA   </li>
   * </ul>
   *
   * This signals management are right for the point of internal chip view,
   * so, for example, if your cartridge use it's IRQ signal for NMI in the C64,
   * and NMI for IRQ, you must changes this default assignement, or the best
   * solution is to send IRQ for NMI and NMI for IRQ in your cartridge
   * implementation
   *
   * @param type the type of signal
   * @param value the value of the signal (0/1)
   */
  public void notifySignal(int type, int value) {
    switch (type) {
      case S_GAME:
      case S_EXROM:
        pla.notifySignal(type, value);               // send signal to PLA
        pla.monitor.opSignal();                      // resume PLA thread
        break;
      case S_NMI:
        cpu.notifySignal(type, value);               // send NMI to cpu
        break;
      case S_IRQ:
        cpu.notifySignal(type, value);               // semd IRQ to cpu
        break;
      case S_DMA:
        and6.notifySignal(type, value);              // send DMA to and port 6
        and3.notifySignal(type, value);              // send DMA to and port 3
        //and6.monitor.opSignal();                   // resume and port 6
        //and3.monitor.opSignal();                   // resume and port 3
        break;
      default:
        System.err.println("ERROR: an invalid "+type+
                           " signal was sent by Cartridge to internal chip");
    }
  }
}